#!/usr/bin/env ruby
require 'gli'
require 'redis'
require 'xcflushd/runner'

include GLI::App

def start_xcflusher(options)
  int_opt_fields = [:threescale_port, :redis_port,
                    :auth_valid_minutes, :reporting_freq_minutes]
  int_opt_fields.each { |opt| options[opt] = options[opt].to_i }
  Xcflushd::Runner.run(options)
end

program_desc 'XC flush daemon'

version Xcflushd::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Starts the daemon'
arg_name 'Describe arguments to run here'
command :run do |c|
  c.desc 'Redis host'
  c.flag :redis_host

  c.desc 'Redis port'
  c.flag :redis_port

  c.desc '3scale backend host'
  c.flag :threescale_host

  c.desc '3scale backend port'
  c.flag :threescale_port, default_value: 80

  c.desc '3scale provider key'
  c.flag :provider_key

  c.desc 'Validity of authorizations (in minutes)'
  c.flag :auth_valid_minutes

  c.desc 'Reporting frequency (in minutes)'
  c.flag :reporting_freq_minutes

  c.desc 'Daemonize'
  c.switch :daemonize

  c.action do |_global_options, options, _args|
    [:threescale_host,
     :provider_key,
     :redis_host,
     :redis_port,
     :auth_valid_minutes,
     :reporting_freq_minutes].each do |opt|
      help_now!("#{opt} is required") unless options[opt]
    end

    if options[:reporting_freq_minutes].to_i >= options[:auth_valid_minutes].to_i
      exit_now!('reporting_freq_minutes needs to be <= auth_valid_minutes. '\
                'Otherwise, auths would be renewed without taking into '\
                'account the new reports.')
    end

    if options[:daemonize]
      require 'daemons'
      begin
        Daemons.run_proc('xcflush') { start_xcflusher(options) }
        # When forking, the parent executes 'exit', and GLI thinks that there
        # has been an error. Let's return the correct exit code.
      rescue SystemExit => e
        e.status
      end
    else
      start_xcflusher(options)
    end
  end
end

pre do |_global, _command, _options, _args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |_global, _command, _options, _args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |_exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
