#!/usr/bin/env ruby
require 'gli'
require 'redis'
require 'xcflushd/runner'

include GLI::App

OPTIONS = [:'threescale-host',
           :'threescale-port',
           :'provider-key',
           :'redis-host',
           :'redis-port',
           :'auth-valid-minutes',
           :'reporting-freq-minutes',
           :'daemonize'].freeze

REQUIRED_OPTIONS = (OPTIONS - [:'daemonize']).freeze

def start_xcflusher(options)
  int_opt_fields = [:'threescale-port', :'redis-port',
                    :'auth-valid-minutes', :'reporting-freq-minutes']
  int_opt_fields.each { |opt| options[opt] = options[opt].to_i }
  Xcflushd::Runner.run(Hash[options.map { |k, v| [k.to_s.gsub('-', '_').to_sym, v] }])
end

# Saves in the options hash those config options present in ENV that have not
# been specified as command arguments.
def read_missing_opts_from_env(options)
  OPTIONS.each do |opt|
    if options[opt].nil?
      # ENV vars have "_" instead of "-" and are written in uppercase.
      options[opt] = ENV[opt.to_s.gsub('-'.freeze, '_'.freeze).upcase]
    end
  end
end

program_desc 'XC flush daemon'

version Xcflushd::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Starts the daemon'
arg_name 'Describe arguments to run here'
command :run do |c|
  c.desc 'Redis host'
  c.flag :'redis-host'

  c.desc 'Redis port'
  c.flag :'redis-port'

  c.desc '3scale backend host'
  c.flag :'threescale-host'

  c.desc '3scale backend port'
  c.flag :'threescale-port', default_value: 80

  c.desc '3scale provider key'
  c.flag :'provider-key'

  c.desc 'Validity of authorizations (in minutes)'
  c.flag :'auth-valid-minutes'

  c.desc 'Reporting frequency (in minutes)'
  c.flag :'reporting-freq-minutes'

  c.desc 'Daemonize'
  c.switch :daemonize

  c.action do |_global_options, options, _args|
    # options contains 2 keys for each option. One is a String and the other a
    # Symbol. That way we can use options['redis-host'] and
    # options[:'redis-host']. That's fine as long as we only read from the
    # hash. If we need to modify it, it is problematic because we need to
    # remember to modify two values. For simplicity, let's just keep the
    # elements that have symbols as keys.
    options.keep_if { |k, _v| k.is_a?(Symbol) }

    read_missing_opts_from_env(options)

    REQUIRED_OPTIONS.each do |opt|
      help_now!("#{opt} is required") unless options[opt]
    end

    if options[:'reporting-freq-minutes'].to_i >= options[:'auth-valid-minutes'].to_i
      exit_now!('reporting-freq-minutes needs to be <= auth-valid-minutes. '\
                'Otherwise, auths would be renewed without taking into '\
                'account the new reports.')
    end

    if options[:daemonize]
      require 'daemons'
      begin
        Daemons.run_proc('xcflush') { start_xcflusher(options) }
        # When forking, the parent executes 'exit', and GLI thinks that there
        # has been an error. Let's return the correct exit code.
      rescue SystemExit => e
        e.status
      end
    else
      start_xcflusher(options)
    end
  end
end

pre do |_global, _command, _options, _args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |_global, _command, _options, _args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |_exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
