#!/usr/bin/env ruby
require 'gli'
require 'redis'
require 'xcflushd/gli_helpers'

include GLI::App
include Xcflushd::GLIHelpers

program_desc 'XC flush daemon'

version Xcflushd::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Starts the XC flusher'
arg_name ' '
command :run do |c|
  c.desc 'Redis URI'
  c.flag [:r, :redis], required: true, type: RedisURI

  c.desc '3scale backend URI'
  c.flag [:b, :backend], required: true, type: BackendURI

  c.desc '3scale provider key'
  c.flag [:k, :'provider-key'], required: true

  c.desc 'Validity of authorizations (in minutes)'
  c.flag [:a, :'auth-ttl'], required: true, type: Integer, must_match: POSITIVE_N_RE

  c.desc 'Reporting frequency (in minutes)'
  c.flag [:f, :frequency], required: true, type: Integer, must_match: POSITIVE_N_RE

  c.desc 'Thread pool minimum and maximum number of threads (min:max)'
  c.flag [:t, :threads], default_value: 'auto', type: PositiveMinMaxInt

  c.desc 'Run this program as a background service'
  c.switch :daemonize, default_value: false, negatable: true, multiple: true

  c.action do |_global_options, options, _args|
    # options contains 2 keys for each option. One is a String and the other a
    # Symbol. That way we can use options['redis'] and options[:redis].
    # That's fine as long as we only read from the hash. If we need to modify
    # it, it is problematic because we need to remember to modify two values.
    # For simplicity, let's just keep the elements that have symbols as keys.
    options.keep_if { |k, _v| k.is_a?(Symbol) }

    if options[:frequency] >= options[:'auth-ttl']
      exit_now!('frequency needs to be <= auth-ttl. '\
                'Otherwise, auths would be renewed without taking into '\
                'account the new reports.')
    end

    if options[:threads] == 'auto'
      options.delete :threads
      options.delete :t
    end

    if options[:prio_threads] == 'auto'
      options.delete :threads
      options.delete 'threads'
    end

    banner = "xcflushd [#{Xcflushd::VERSION}]"

    if options[:daemonize]
      require 'daemons'
      begin
        Daemons.run_proc(banner) { start_xcflusher(options) }
        # When forking, the parent executes 'exit', and GLI thinks that there
        # has been an error. Let's return the correct exit code.
      rescue SystemExit => e
        e.status
      end
    else
      set_title(banner)
      start_xcflusher(options)
    end
  end
end

pre do |_global, _command, _options, _args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |_global, _command, _options, _args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |_exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
